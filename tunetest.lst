   1                              * = $C000
   2                               
   3                              ; --- position of the dot ------------------
   4                   
   5                              xpos = 32
   6                              ypos = 22
   7                              screen = $0400
   8                              screenpos = screen + (40 * ypos) + xpos
   9                              colorram = $D800
  10                              colorpos = colorram + (40 * ypos) + xpos
  11                   
  12                              colorramOffset = colorram - screen
  13                   
  14                              ; --- raster lines -------------------------
  15                   
  16                              ; 10 ms are 156.25 raster lines
  17                              ; 20 ms are 312.50 raster lines
  18                              ;
  19                              ; With ypos = 22, the dot starts on raster line
  20                              ; 227. Raster line 71 is about 10 ms before that.
  21                   
  22                              rasterStartVisible = 51
  23                   
  24                              rasterSample       = 71    ; when to sample the data line and update the frame
  25                              rasterDot          = rasterStartVisible + (8 * ypos)
  26                              rasterTarget       = (rasterDot + 10)
  27                              rasterBarStart     = (rasterTarget - 14)
  28                              rasterBarEnd       = (rasterTarget + 14)
  29                   
  30                              ; --- other screen positions ---------------
  31                   
  32                              yFirstSequence = 9
  33                              xSequenceMarker = 2
  34                   
  35                              screenposFirstSequenceMarker = screen + (40 * yFirstSequence) + xSequenceMarker
  36                               
  37                              yData = 16
  38                   
  39                              screenposDataStart = screen + (40 * yData)
  40                              screenposDataEnd   = screenposDataStart + (3 * 40)
  41                   
  42                              ; --- control characters -------------------
  43                   
  44                              ctrlWhite      = $05
  45                              ctrlNewline    = $0D
  46                              ctrlDown       = $11
  47                              ctrlReverseOn  = $12
  48                              ctrlHome       = $13
  49                              ctrlRed        = $1C
  50                              ctrlGreen      = $1E
  51                              ctrlBlue       = $1F
  52                              ctrlOrange     = $81
  53                              ctrlBlack      = $90
  54                              ctrlReverseOff = $92
  55                              ctrlClear      = $93
  56                              ctrlBrown      = $95
  57                              ctrlLightRed   = $96
  58                              ctrlDarkGrey   = $97
  59                              ctrlMediumGrey = $98
  60                              ctrlLightGreen = $99
  61                              ctrlLightBlue  = $9A
  62                              ctrlLightGrey  = $9B
  63                              ctrlPurple     = $9C
  64                              ctrlYellow     = $9E
  65                              ctrlCyan       = $9F
  66                   
  67                              ; --- poke colors --------------------------
  68                   
  69                              pokeBlack      = $00
  70                              pokeRed        = $02
  71                              pokeGreen      = $05
  72                              pokeBlue       = $06
  73                              pokeYellow     = $07
  74                              pokeLightRed   = $0A
  75                              pokeDarkGrey   = $0C
  76                              pokeLightGreen = $0D
  77                              pokeLightBlue  = $0E
  78                   
  79                              ; --- key codes ----------------------------
  80                   
  81                              keyRunStop     = $03
  82                              keyF5          = $87
  83                              keyF7          = $88
  84                              
  85                              ; --- kernal vectors -----------------------
  86                              
  87                              outch          = $FFD2
  88                              readkey        = $FFE4
  89                              kernalIrq      = $EA31 ; standard IRQ handler
  90                              kernalIrqRet   = $EA81 ; return from IRQ
  91                   
  92                              ; --- zeropage allocations for variables ---
  93                              
  94                              zpCurrentByte       = $02
  95                              zpExpectedBit       = $07
  96                              zpMainLo            = $0B ; for use by the main program
  97                              zpMainHi            = $0C ; for use by the main program
  98                              zpSampleLo          = $14 ; running pointer for sampling IRQ
  99                              zpSampleHi          = $15 ; running pointer for sampling IRQ
 100                              zpAvailableBits     = $FB
 101                              zpSequenceIndex     = $FC
 102                              zpTempLo            = $FC ; use only during initialization
 103                              zpNextBytePointerLo = $FD
 104                              zpTempHi            = $FD ; use only during initialization
 105                              zpNextBytePointerHi = $FE
 106                              zpRemainingBitsLo   = $43
 107                              zpRemainingBitsHi   = $44
 108                   
 109                              ; --- interrupt vectors --------------------
 110                   
 111                              vecIrq              = $0314
 112                   
 113                              ; --- VIC registers ------------------------
 114                   
 115                              vicControl          = $D011
 116                              vicRaster           = $D012
 117                              vicIrqFlag          = $D019
 118                              vicIrqMask          = $D01A
 119                              vicBorder           = $D020
 120                              vicBackground       = $D021
 121                   
 122                              ; --- CIA registers ------------------------
 123                   
 124                              ciaIntCtrl1         = $DC0D ; interrupt control
 125                   
 126                              ciaDataB2           = $DD01 ; data, port B
 127                              ciaDataDirB2        = $DD03 ; data direction, port B
 128                              ciaIntCtrl2         = $DD0D ; interrupt control
 129                   
 130                              ; --- initialize the program ---
 131                              
 132 c000 a9 00        Init       LDA #0
 133 c002 8d 20 d0                STA vicBorder        ; border color: black
 134 c005 8d 21 d0                STA vicBackground    ; background color: black
 135 c008 8d 03 dd                STA ciaDataDirB2     ; all port B bits are inputs
 136                            
 137 c00b a9 93                   LDA #ctrlClear       ; clear the screen
 138 c00d 20 d2 ff                JSR outch
 139                   
 140 c010 a2 3d                   LDX #<Usage          ; print the usage message
 141 c012 a0 c2                   LDY #>Usage
 142 c014 20 00 c2                JSR PrintStr
 143                   
 144 c017 a9 80                   LDA #<screenposDataStart  ; set up screen pointer for sampling
 145 c019 85 14                   STA zpSampleLo
 146 c01b a9 06                   LDA #>screenposDataStart
 147 c01d 85 15                   STA zpSampleHi
 148                   
 149 c01f a9 ff                   LDA #$FF
 150 c021 85 07                   STA zpExpectedBit    ; no expected bit, yet
 151                   
 152 c023 a9 00                   LDA #0               ; start sequence 0
 153 c025 85 fc                   STA zpSequenceIndex
 154 c027 20 b6 c0                JSR StartSeq
 155                              
 156 c02a 78                      SEI                  ; set interrupt bit, make the CPU ignore interrupt requests
 157                   
 158 c02b a9 7f                   LDA #%01111111       ; switch off interrupt signals from CIA-1
 159 c02d 8d 0d dc                STA ciaIntCtrl1
 160                   
 161 c030 2d 11 d0                AND vicControl       ; clear most significant bit of VIC's raster register
 162 c033 8d 11 d0                STA vicControl
 163                   
 164 c036 8d 0d dc                STA ciaIntCtrl1      ; acknowledge pending interrupts from CIA-1
 165 c039 8d 0d dd                STA ciaIntCtrl2      ; acknowledge pending interrupts from CIA-2
 166                   
 167 c03c a9 47                   LDA #rasterSample    ; set rasterline where interrupt shall occur
 168 c03e 8d 12 d0                STA vicRaster
 169                   
 170 c041 a9 33                   LDA #<Irq            ; set interrupt vectors, pointing to interrupt service routine below
 171 c043 8d 14 03                STA vecIrq
 172 c046 a9 c1                   LDA #>Irq
 173 c048 8d 15 03                STA vecIrq + 1
 174                   
 175 c04b a9 01                   LDA #%00000001       ; enable raster interrupt signals from VIC
 176 c04d 8d 1a d0                STA vicIrqMask
 177                   
 178 c050 4c 83 c0                JMP HaveSeq          ; start the first sequence and enable interrupts
 179                   
 180                              ; --- main loop ---
 181                   
 182 c053 20 e4 ff     MainLoop   JSR readkey
 183 c056 f0 fb                   BEQ MainLoop         ; no key? -> repeat
 184                   
 185 c058 c9 03                   CMP #keyRunStop      ; has RUN/STOP been pressed?
 186 c05a f0 59                   BEQ Exit             ; if yes, then exit
 187                   
 188 c05c c9 87                   CMP #keyF5
 189 c05e f0 07                   BEQ PrevSeq
 190                   
 191 c060 c9 88                   CMP #keyF7
 192 c062 f0 0b                   BEQ NextSeq
 193                   
 194 c064 4c 53 c0                JMP MainLoop
 195                   
 196                              ; switch to prev sequence
 197 c067 78           PrevSeq    SEI                  ; suspend interrupts
 198 c068 c6 fc                   DEC zpSequenceIndex
 199 c06a 30 13                   BMI LastSeq
 200 c06c 4c 83 c0                JMP HaveSeq
 201                   
 202                              ; switch to next sequence
 203 c06f 78           NextSeq    SEI                  ; suspend interrupts
 204 c070 e6 fc                   INC zpSequenceIndex
 205 c072 a5 fc                   LDA zpSequenceIndex
 206 c074 c9 06                   CMP #nSequences
 207 c076 d0 0b                   BNE HaveSeq
 208                   
 209 c078 a9 00        FirstSeq   LDA #0
 210 c07a 85 fc                   STA zpSequenceIndex
 211 c07c 4c 83 c0                JMP HaveSeq
 212                   
 213 c07f a9 05        LastSeq    LDA #(nSequences - 1)
 214 c081 85 fc                   STA zpSequenceIndex
 215                   
 216 c083 20 b6 c0     HaveSeq    JSR StartSeq
 217 c086 58                      CLI     ; enable interrupts again
 218                   
 219                              ; --- mark the currently selected sequence
 220                   
 221 c087 a9 6a                   LDA #<screenposFirstSequenceMarker
 222 c089 85 0b                   STA zpMainLo
 223 c08b a9 05                   LDA #>screenposFirstSequenceMarker
 224 c08d 85 0c                   STA zpMainHi
 225                   
 226 c08f a2 00                   LDX #0
 227 c091 e4 fc        MarkLoop   CPX zpSequenceIndex
 228 c093 f0 05                   BEQ MarkThis
 229 c095 a9 20                   LDA #$20 ; ' '
 230 c097 4c 9c c0                JMP MarkOther
 231 c09a a9 3e        MarkThis   LDA #$3E ; '>'
 232 c09c a0 00        MarkOther  LDY #0
 233 c09e 91 0b                   STA (zpMainLo),Y
 234                   
 235 c0a0 18                      CLC
 236 c0a1 a5 0b                   LDA zpMainLo
 237 c0a3 69 28                   ADC #40
 238 c0a5 85 0b                   STA zpMainLo
 239 c0a7 a5 0c                   LDA zpMainHi
 240 c0a9 69 00                   ADC #0
 241 c0ab 85 0c                   STA zpMainHi
 242                   
 243 c0ad e8                      INX
 244 c0ae e0 06                   CPX #nSequences
 245 c0b0 f0 a1                   BEQ MainLoop
 246 c0b2 4c 91 c0                JMP MarkLoop
 247                   
 248 c0b5 60           Exit       RTS
 249                   
 250                              ; --- start a sequence (sequence index given in zpSequenceIndex)
 251                   
 252 c0b6 a5 fc        StartSeq   LDA zpSequenceIndex      ; multiply sequence index by 4
 253 c0b8 0a                      ASL A
 254 c0b9 0a                      ASL A
 255 c0ba 18                      CLC
 256 c0bb 69 17                   ADC #<Sequences          ; add to address of Sequences
 257 c0bd 85 fd                   STA zpNextBytePointerLo  ; use next byte pointer temporarily to store the address
 258 c0bf a9 00                   LDA #0
 259 c0c1 69 c2                   ADC #>Sequences
 260 c0c3 85 fe                   STA zpNextBytePointerHi
 261                   
 262                              ; load and store the number of bits in the sequence
 263 c0c5 a0 00                   LDY #0
 264 c0c7 b1 fd                   LDA (zpNextBytePointerLo),Y
 265 c0c9 85 43                   STA zpRemainingBitsLo
 266 c0cb a0 01                   LDY #1
 267 c0cd b1 fd                   LDA (zpNextBytePointerLo),Y
 268 c0cf 85 44                   STA zpRemainingBitsHi
 269                   
 270                              ; load and store the pointer to the sequence data
 271                   
 272 c0d1 a0 02                   LDY #2
 273 c0d3 b1 fd                   LDA (zpNextBytePointerLo),Y
 274 c0d5 48                      PHA
 275 c0d6 a0 03                   LDY #3
 276 c0d8 b1 fd                   LDA (zpNextBytePointerLo),Y
 277 c0da 85 fe                   STA zpNextBytePointerHi
 278 c0dc 68                      PLA
 279 c0dd 85 fd                   STA zpNextBytePointerLo
 280                   
 281                              ; clear zpAvailableBits
 282 c0df a9 00                   LDA #0
 283 c0e1 85 fb                   STA zpAvailableBits
 284                   
 285 c0e3 60                      RTS
 286                   
 287                              ; --- get the next bit in the sequence (return it in A)
 288                   
 289                              ; check whether we have available bits in zpCurrentByte
 290 c0e4 a5 fb        NextBit    LDA zpAvailableBits
 291 c0e6 d0 3d                   BNE HaveBit 
 292                   
 293                              ; --- no; we must load a byte from the sequence data
 294                   
 295                              ; check whether we have remaining bits in the sequence
 296                              ; (and therefore at least one byte remaining in the
 297                              ; sequence data)
 298 c0e8 a5 44                   LDA zpRemainingBitsHi
 299 c0ea d0 07                   BNE HaveByte
 300 c0ec a5 43                   LDA zpRemainingBitsLo
 301 c0ee d0 03                   BNE HaveByte
 302                   
 303                              ; --- no; we must restart the sequence
 304                   
 305 c0f0 20 b6 c0                JSR StartSeq
 306                   
 307                              ; --- there is at least one bit in the sequence remaining,
 308                              ;     so there is at least one more byte to load from the
 309                              ;     sequence data
 310                   
 311                              ; --- load the next byte from the sequence data,
 312                              ;     store it in zpCurrentByte, and update pointers
 313                              ;     and counters
 314                   
 315 c0f3 a0 00        HaveByte   LDY #0
 316 c0f5 b1 fd                   LDA (zpNextBytePointerLo),Y
 317 c0f7 85 02                   STA zpCurrentByte
 318                   
 319                              ; increase the next-byte-pointer
 320 c0f9 e6 fd                   INC zpNextBytePointerLo
 321 c0fb d0 02                   BNE PtrDone
 322 c0fd e6 fe                   INC zpNextBytePointerHi
 323                   
 324 c0ff a5 44        PtrDone    LDA zpRemainingBitsHi   ; check if at least 8 bits are remaining
 325 c101 d0 11                   BNE Have8
 326 c103 a5 43                   LDA zpRemainingBitsLo
 327 c105 c9 08                   CMP #8
 328 c107 10 0b                   BPL Have8
 329                   
 330                              ; we have less than 8 bits left (their number is in A)
 331 c109 85 fb                   STA zpAvailableBits
 332 c10b a9 00                   LDA #0
 333 c10d 85 43                   STA zpRemainingBitsLo ; clear number of remaining bits
 334 c10f 85 44                   STA zpRemainingBitsHi
 335 c111 4c 25 c1                JMP HaveBit 
 336                   
 337                              ; --- we have at least 8 bits remaining
 338                   
 339 c114 a9 08        Have8      LDA #8
 340 c116 85 fb                   STA zpAvailableBits
 341                              ; decrement the remaining bits counter by 8
 342 c118 a5 43                   LDA zpRemainingBitsLo
 343 c11a 38                      SEC
 344 c11b e9 08                   SBC #8
 345 c11d 85 43                   STA zpRemainingBitsLo
 346 c11f a5 44                   LDA zpRemainingBitsHi
 347 c121 e9 00                   SBC #0
 348 c123 85 44                   STA zpRemainingBitsHi
 349                   
 350                              ; --- we have at least one bit available in zpCurrentByte
 351                   
 352 c125 a5 02        HaveBit    LDA zpCurrentByte ; shift the LSB out of zpCurrentByte
 353 c127 4a                      LSR
 354 c128 85 02                   STA zpCurrentByte
 355 c12a a9 00                   LDA #0            ; and store it (the LSB) on the stack
 356 c12c 69 00                   ADC #0
 357 c12e 48                      PHA
 358                   
 359                              ; decrement zpAvailableBits
 360 c12f c6 fb                   DEC zpAvailableBits
 361                   
 362 c131 68                      PLA               ; restore the LSB from the stack
 363 c132 60                      RTS
 364                   
 365                              ; --- raster interrupt, once per frame for sampling and updating the dot ----
 366                              
 367 c133 ad 01 dd     Irq        LDA ciaDataB2        ; sample the data line
 368 c136 0a                      ASL A
 369 c137 a9 30                   LDA #$30             ; '0'
 370 c139 69 00                   ADC #0               ; set A to '0' or '1', depending on what we sampled
 371 c13b a0 00                   LDY #0
 372 c13d 91 14                   STA (zpSampleLo),Y
 373                   
 374                              ; compare with expected bit
 375 c13f 38                      SEC
 376 c140 e9 30                   SBC #$30             ; convert back to numerical 0 or 1
 377 c142 c5 07                   CMP zpExpectedBit
 378 c144 f0 0b                   BEQ Same
 379 c146 a9 ff                   LDA #$FF
 380 c148 c5 07                   CMP zpExpectedBit
 381 c14a f0 0a                   BEQ NoExpected
 382 c14c a9 02                   LDA #pokeRed
 383 c14e 4c 58 c1                JMP DoneComp
 384 c151 a9 0d        Same       LDA #pokeLightGreen
 385 c153 4c 58 c1                JMP DoneComp
 386 c156 a9 0c        NoExpected LDA #pokeDarkGrey
 387                   
 388                              ; write color to color ram
 389 c158 48           DoneComp   PHA
 390 c159 18                      CLC
 391 c15a a5 14                   LDA zpSampleLo
 392 c15c 69 00                   ADC #<colorramOffset
 393 c15e 85 14                   STA zpSampleLo
 394 c160 a5 15                   LDA zpSampleHi
 395 c162 69 d4                   ADC #>colorramOffset
 396 c164 85 15                   STA zpSampleHi
 397 c166 68                      PLA
 398 c167 91 14                   STA (zpSampleLo),Y
 399 c169 38                      SEC
 400 c16a a5 14                   LDA zpSampleLo
 401 c16c e9 00                   SBC #<colorramOffset
 402 c16e 85 14                   STA zpSampleLo
 403 c170 a5 15                   LDA zpSampleHi
 404 c172 e9 d4                   SBC #>colorramOffset
 405 c174 85 15                   STA zpSampleHi
 406                   
 407                              ; increase output position for sampled data
 408 c176 e6 14                   INC zpSampleLo
 409 c178 d0 02                   BNE IncDone
 410 c17a e6 15                   INC zpSampleHi
 411                   
 412                              ; check whether we need to wrap the output position around
 413 c17c a5 14        IncDone    LDA zpSampleLo
 414 c17e c9 f8                   CMP #<screenposDataEnd
 415 c180 d0 0e                   BNE NotEnd
 416 c182 a5 15                   LDA zpSampleHi
 417 c184 c9 06                   CMP #>screenposDataEnd
 418 c186 d0 08                   BNE NotEnd
 419                   
 420                              ; reset to the beginning of the output area
 421 c188 a9 80                   LDA #<screenposDataStart
 422 c18a 85 14                   STA zpSampleLo
 423 c18c a9 06                   LDA #>screenposDataStart
 424 c18e 85 15                   STA zpSampleHi
 425                   
 426                              ; write a space after the most recent bit
 427 c190 a9 20        NotEnd     LDA #$20             ; ' '
 428 c192 91 14                   STA (zpSampleLo),Y
 429                   
 430                              ; update the dot
 431 c194 20 e4 c0                JSR NextBit
 432 c197 85 07                   STA zpExpectedBit
 433 c199 c9 00                   CMP #0
 434 c19b f0 08                   BEQ ClearIt
 435 c19d a9 51        SetIt      LDA #81
 436 c19f 8d 90 07                STA screenpos
 437 c1a2 4c aa c1                JMP Done
 438 c1a5 a9 20        ClearIt    LDA #32
 439 c1a7 8d 90 07                STA screenpos
 440 c1aa a9 01        Done       LDA #1
 441 c1ac 8d 90 db                STA colorpos
 442                   
 443                              ; check whether we are in the tuning sequence
 444                              ; and wether we are expecting a high-to-low
 445                              ; transition
 446 c1af a5 fc                   LDA zpSequenceIndex
 447 c1b1 d0 13                   BNE AckIrq
 448 c1b3 a5 07                   LDA zpExpectedBit
 449 c1b5 d0 0f                   BNE AckIrq
 450                   
 451                              ; we are in the tuning sequence and we expect
 452                              ; a high-to-low transition.
 453                              ; set up the tuning-specific raster IRQ handler
 454                   
 455 c1b7 a9 df                   LDA #rasterBarStart
 456 c1b9 8d 12 d0                STA vicRaster
 457 c1bc a9 cc                   LDA #<TuneIrq 
 458 c1be 8d 14 03                STA vecIrq
 459 c1c1 a9 c1                   LDA #>TuneIrq
 460 c1c3 8d 15 03                STA vecIrq + 1
 461                   
 462 c1c6 0e 19 d0     AckIrq     ASL vicIrqFlag       ; acknowledge the interrupt by clearing the VIC's interrupt flag
 463 c1c9 4c 31 ea                JMP kernalIrq        ; jump into KERNAL's standard interrupt service routine to handle keyboard scan, cursor display etc.
 464                   
 465                              ; --- raster interrupt for tuning --------------------------
 466                   
 467 c1cc ad 12 d0     TuneIrq    LDA vicRaster
 468 c1cf c9 fb                   CMP #rasterBarEnd
 469 c1d1 10 13                   BPL BarEnd
 470                   
 471                              ; color the border depending on the state of the data line
 472 c1d3 ad 01 dd                LDA ciaDataB2
 473 c1d6 0a                      ASL A
 474 c1d7 b0 05                   BCS DataHi
 475 c1d9 a9 06                   LDA #pokeBlue
 476 c1db 4c e0 c1                JMP DataDone
 477 c1de a9 07        DataHi     LDA #pokeYellow
 478 c1e0 8d 20 d0     DataDone   STA vicBorder
 479 c1e3 4c cc c1                JMP TuneIrq
 480                   
 481                              ; end of tuning bar; switch back to black border
 482                              ; and the sampling IRQ
 483 c1e6 a9 00        BarEnd     LDA #pokeBlack
 484 c1e8 8d 20 d0                STA vicBorder
 485                              
 486                              ; set up the sample IRQ
 487 c1eb a9 47                   LDA #rasterSample
 488 c1ed 8d 12 d0                STA vicRaster
 489 c1f0 a9 33                   LDA #<Irq
 490 c1f2 8d 14 03                STA vecIrq
 491 c1f5 a9 c1                   LDA #>Irq
 492 c1f7 8d 15 03                STA vecIrq + 1
 493                   
 494 c1fa 0e 19 d0     AckIrqRet  ASL vicIrqFlag       ; acknowledge the interrupt by clearing the VIC's interrupt flag
 495 c1fd 4c 81 ea                JMP kernalIrqRet     ; jump into KERNAL code for returning from IRQ handler
 496                   
 497                              ; --- print string (pointer to string is in Y:X) -----------
 498                   
 499 c200 86 fc        PrintStr   STX zpTempLo
 500 c202 84 fd                   STY zpTempHi
 501                   
 502 c204 a0 00        PrintLoop  LDY #0
 503 c206 b1 fc                   LDA (zpTempLo),Y     ; A <- byte at zeropage[zpTempHi]:zeropage[zpTempLo]
 504 c208 f0 0c                   BEQ EndStr
 505 c20a 20 d2 ff                JSR outch
 506 c20d e6 fc                   INC zpTempLo
 507 c20f d0 f3                   BNE PrintLoop
 508 c211 e6 fd                   INC zpTempHi
 509 c213 4c 04 c2                JMP PrintLoop
 510                              
 511 c216 60           EndStr     RTS 
 512                   
 513                              ; --- sequence definitions ---------------------------------
 514                              
 515                              ; number of sequences
 516                              nSequences = 6
 517                   
 518                              ; list of sequences, 4 bytes per sequence
 519 c217 02 00 38 c2 
 520 c21b 32 00 2f c2 
 521 c21f 01 00 37 c2 
 522 c223 01 00 36 c2 
 523 c227 0e 00 39 c2 
 524 c22b 0e 00 3b c2 
 525                   
 526 c22f 01 00 00 00  seq1Hz     .byte $01, $00, $00, $00, $00, $00, $00
     c233 00 00 00 
 527 c236 01           seqOn      .byte $01
 528 c237 00           seqOff     .byte $00
 529 c238 01           seqAlt     .byte $01
 530 c239 25 02        seqVary0   .byte %00100101, %00000010
 531 c23b da 3d        seqVary1   .byte %11011010, %00111101
 532                   
 533                              ; --- strings ----------------------------------------------
 534                              
 535 c23d 93 05        Usage      .byte ctrlClear, ctrlWhite
 536 c23f 20 20 20 20             .text "       == c64 light fantastic ==        "
     c243 20 20 20 3d 
     c247 3d 20 43 36 
     c24b 34 20 4c 49 
     c24f 47 48 54 20 
     c253 46 41 4e 54 
     c257 41 53 54 49 
     c25b 43 20 3d 3d 
     c25f 20 20 20 20 
     c263 20 20 20 20 
 537 c267 20 20 20 20             .text "          tune & test program           "
     c26b 20 20 20 20 
     c26f 20 20 54 55 
     c273 4e 45 20 26 
     c277 20 54 45 53 
     c27b 54 20 50 52 
     c27f 4f 47 52 41 
     c283 4d 20 20 20 
     c287 20 20 20 20 
     c28b 20 20 20 20 
 538 c28f 0d                      .byte ctrlNewline
 539 c290 0d 9b                   .byte ctrlNewline, ctrlLightGrey
 540 c292 2a 20 50 52             .text "* press "
     c296 45 53 53 20 
 541 c29a 12 1c                   .byte ctrlReverseOn, ctrlRed
 542 c29c 52 55 4e 2f             .text "run/stop"
     c2a0 53 54 4f 50 
 543 c2a4 92 9b                   .byte ctrlReverseOff, ctrlLightGrey
 544 c2a6 20 54 4f 20             .text " to quit."
     c2aa 51 55 49 54 
     c2ae 2e 
 545 c2af 0d                      .byte ctrlNewline
 546 c2b0 0d                      .byte ctrlNewline
 547 c2b1 2a 20 50 52             .text "* press "
     c2b5 45 53 53 20 
 548 c2b9 05                      .byte ctrlWhite
 549 c2ba 46 35                   .text "f5"
 550 c2bc 9b                      .byte ctrlLightGrey
 551 c2bd 20 2f 20                .text " / "
 552 c2c0 05                      .byte ctrlWhite
 553 c2c1 46 37                   .text "f7"
 554 c2c3 9b                      .byte ctrlLightGrey
 555 c2c4 20 54 4f 20             .text " to cycle through  the   "
     c2c8 43 59 43 4c 
     c2cc 45 20 54 48 
     c2d0 52 4f 55 47 
     c2d4 48 20 20 54 
     c2d8 48 45 20 20 
     c2dc 20 
 556 c2dd 20 20 54 45             .text "  test sequences."
     c2e1 53 54 20 53 
     c2e5 45 51 55 45 
     c2e9 4e 43 45 53 
     c2ed 2e 
 557 c2ee 0d                      .byte ctrlNewline
 558 c2ef 0d                      .byte ctrlNewline
 559 c2f0 20 20                   .text "  "
 560 c2f2 9e                      .byte ctrlYellow
 561 c2f3 20                      .text " "
 562 c2f4 9b                      .byte ctrlLightGrey
 563 c2f5 20 54 55 4e             .text " tuning (alternating on/off)"
     c2f9 49 4e 47 20 
     c2fd 28 41 4c 54 
     c301 45 52 4e 41 
     c305 54 49 4e 47 
     c309 20 4f 4e 2f 
     c30d 4f 46 46 29 
 564 c311 0d                      .byte ctrlNewline
 565 c312 20 20                   .text "  "
 566 c314 9f                      .byte ctrlCyan
 567 c315 20                      .text " "
 568 c316 9b                      .byte ctrlLightGrey
 569 c317 20 31 48 5a             .text " 1hz blinking"
     c31b 20 42 4c 49 
     c31f 4e 4b 49 4e 
     c323 47 
 570 c324 0d                      .byte ctrlNewline
 571 c325 20 20                   .text "  "
 572 c327 9f                      .byte ctrlCyan
 573 c328 20                      .text " "
 574 c329 9b                      .byte ctrlLightGrey
 575 c32a 20 41 4c 57             .text " always off"
     c32e 41 59 53 20 
     c332 4f 46 46 
 576 c335 0d                      .byte ctrlNewline
 577 c336 20 20                   .text "  "
 578 c338 9f                      .byte ctrlCyan
 579 c339 20                      .text " "
 580 c33a 9b                      .byte ctrlLightGrey
 581 c33b 20 41 4c 57             .text " always on"
     c33f 41 59 53 20 
     c343 4f 4e 
 582 c345 0d                      .byte ctrlNewline
 583 c346 20 20                   .text "  "
 584 c348 9f                      .byte ctrlCyan
 585 c349 20                      .text " "
 586 c34a 9b                      .byte ctrlLightGrey
 587 c34b 20 56 41 52             .text " varying off time"
     c34f 59 49 4e 47 
     c353 20 4f 46 46 
     c357 20 54 49 4d 
     c35b 45 
 588 c35c 0d                      .byte ctrlNewline
 589 c35d 20 20                   .text "  "
 590 c35f 9f                      .byte ctrlCyan
 591 c360 20                      .text " "
 592 c361 9b                      .byte ctrlLightGrey
 593 c362 20 56 41 52             .text " varying on time"
     c366 59 49 4e 47 
     c36a 20 4f 4e 20 
     c36e 54 49 4d 45 
 594 c372 0d                      .byte ctrlNewline
 595 c373 0d                      .byte ctrlNewline
 596 c374 0d                      .byte ctrlNewline
 597 c375 0d                      .byte ctrlNewline
 598 c376 0d                      .byte ctrlNewline
 599 c377 0d                      .byte ctrlNewline
 600 c378 57 48 45 4e             .text "when tuning, adjust r6 such"
     c37c 20 54 55 4e 
     c380 49 4e 47 2c 
     c384 20 41 44 4a 
     c388 55 53 54 20 
     c38c 52 36 20 53 
     c390 55 43 48 
 601 c393 0d                      .byte ctrlNewline
 602 c394 54 48 41 54             .text "that "
     c398 20 
 603 c399 12 9e                   .byte ctrlReverseOn, ctrlYellow
 604 c39b 59 45 4c 4c             .text "yellow"
     c39f 4f 57 
 605 c3a1 92 9b                   .byte ctrlReverseOff, ctrlLightGrey
 606 c3a3 20 41 4e 44             .text " and "
     c3a7 20 
 607 c3a8 12 1f                   .byte ctrlReverseOn, ctrlBlue
 608 c3aa 42 4c 55 45 
 609 c3ae 92 9b 0d                .byte ctrlReverseOff, ctrlLightGrey, ctrlNewline
 610 c3b1 42 4f 52 44             .text "borders have the same size."
     c3b5 45 52 53 20 
     c3b9 48 41 56 45 
     c3bd 20 54 48 45 
     c3c1 20 53 41 4d 
     c3c5 45 20 53 49 
     c3c9 5a 45 2e 
 611 c3cc 0d                      .byte ctrlNewline
 612 c3cd 4f 4e 4c 59             .text "only "
     c3d1 20 
 613 c3d2 12 1f                   .byte ctrlReverseOn, ctrlBlue
 614 c3d4 42 4c 55 45             .text "blue  "
     c3d8 20 20 
 615 c3da 92 9b                   .byte ctrlReverseOff, ctrlLightGrey
 616 c3dc 3a 20 49 4e             .text ": increase r6"
     c3e0 43 52 45 41 
     c3e4 53 45 20 52 
     c3e8 36 
 617 c3e9 0d                      .byte ctrlNewline
 618 c3ea 4f 4e 4c 59             .text "only "
     c3ee 20 
 619 c3ef 12 9e                   .byte ctrlReverseOn, ctrlYellow
 620 c3f1 59 45 4c 4c             .text "yellow"
     c3f5 4f 57 
 621 c3f7 92 9b                   .byte ctrlReverseOff, ctrlLightGrey
 622 c3f9 3a 20 44 45             .text ": decrease r6"
     c3fd 43 52 45 41 
     c401 53 45 20 52 
     c405 36 
 623 c406 00                      .byte 0
 624                   
 625                   
